# Domain Models Documentation

This directory contains comprehensive documentation for all domain models in the Mystira application.

## Overview

Domain models represent the core business entities and their relationships. They are located in `Mystira.App.Domain.Models` and are used throughout the application.

## Domain Model Categories

### Core Game Models

- [Scenario](./scenario.md) - Game scenarios (stories) with scenes, characters, and choices
- [GameSession](./game-session.md) - Active playthroughs of scenarios
- [Scene](./scenario.md#scene) - Individual scenes within scenarios
- [Branch](./scenario.md#branch) - Choices/branches in scenes
- [EchoLog](./scenario.md#echolog) - Echo logs generated by choices
- [CompassChange](./scenario.md#compasschange) - Compass value changes
- [EchoReveal](./scenario.md#echoreveal) - Echo reveal mechanics
- [CompassTracking](./compass.md#compasstracking) - Compass value tracking
- [Compass](./compass.md) - Compass domain models and architecture

### Character Models

- [ScenarioCharacter](./scenario.md#scenariocharacter) - Characters within scenarios
- [ScenarioCharacterMetadata](./scenario.md#scenariocharactermetadata) - Character metadata
- [CharacterMap](./character-map.md) - Reusable character definitions
- [CharacterMetadata](./character-map.md#charactermetadata) - Character map metadata

### User Models

- [Account](./account.md) - User accounts with authentication
- [UserProfile](./user-profile.md) - Individual player profiles
- [PendingSignup](./pending-signup.md) - Passwordless authentication signups

### Badge & Achievement Models

- [UserBadge](./user-badge.md) - Badges earned by user profiles
- [BadgeConfiguration](./badge-configuration.md) - Badge configuration definitions
- [SessionAchievement](./game-session.md#sessionachievement) - Session-level achievements

### Media & Content Models

- [MediaReferences](./scenario.md#mediareferences) - Media references in scenarios
- [AvatarConfiguration](./avatar-configuration.md) - Avatar configurations by age group
- [ContentBundle](./content-bundle.md) - Content bundles (scenario collections)

### Supporting Models

- [OnboardingStep](./onboarding-step.md) - Onboarding step definitions
- [StringEnum](./string-enum.md) - Base class for string-based enums
- [Archetype](./archetype.md) - Character archetypes
- [CoreAxis](./core-axis.md) - Compass core axes
- [EchoType](./echo-type.md) - Echo types
- [FantasyTheme](./fantasy-theme.md) - Fantasy themes
- [AgeGroup](./user-profile.md#agegroup) - Age group definitions

## Domain Model Principles

### Immutability

Domain models are mutable by design to support Entity Framework Core change tracking.

### Validation

Domain models include validation logic where appropriate (e.g., `Scenario.Validate()`).

### Rich Domain Models

Domain models contain business logic and helper methods (e.g., `GameSession.GetTotalElapsedTime()`, `UserProfile.UpdateAgeGroupFromBirthDate()`).

### StringEnum Pattern

Many domain concepts use the `StringEnum<T>` pattern for type-safe string values:

- `Archetype`
- `CoreAxis`
- `EchoType`
- `FantasyTheme`
- `AgeGroup`

## Relationships

### Scenario Relationships

- `Scenario` → `List<ScenarioCharacter>`
- `Scenario` → `List<Scene>`
- `Scene` → `List<Branch>`
- `Scene` → `List<EchoReveal>`
- `Branch` → `EchoLog?`
- `Branch` → `CompassChange?`

### Game Session Relationships

- `GameSession` → `Scenario` (via `ScenarioId`)
- `GameSession` → `Account` (via `AccountId`)
- `GameSession` → `UserProfile` (via `ProfileId`)
- `GameSession` → `Dictionary<string, CompassTracking>`
- `GameSession` → `List<SessionChoice>`
- `GameSession` → `List<EchoLog>`
- `GameSession` → `List<SessionAchievement>`

### User Relationships

- `Account` → `List<UserProfile>` (via `UserProfileIds`)
- `UserProfile` → `Account` (via `AccountId`)
- `UserProfile` → `List<UserBadge>` (via `EarnedBadges`)

### Badge Relationships

- `UserBadge` → `UserProfile` (via `UserProfileId`)
- `UserBadge` → `BadgeConfiguration` (via `BadgeConfigurationId`)
- `UserBadge` → `GameSession` (via `GameSessionId`, optional)
- `UserBadge` → `Scenario` (via `ScenarioId`, optional)

## Persistence

Domain models are persisted using:

- **Entity Framework Core** - For Cosmos DB and In-Memory databases
- **Repositories** - Abstract data access through repository interfaces
- **Unit of Work** - Manages transactions and coordinates repositories

## Recommended Use Cases by Domain Model

This section documents what use cases should be implemented for each domain model to follow hexagonal architecture principles. Currently, many operations are handled directly in services; these should be migrated to dedicated use cases.

### Core Game Domain Models

#### Scenario Domain Model

**Current Status**: ✅ Fully implemented with use cases

**Use Cases**:

- ✅ `CreateScenarioUseCase` - Create new scenario with validation
- ✅ `GetScenariosUseCase` - Retrieve scenarios with filtering and pagination
- ✅ `UpdateScenarioUseCase` - Update existing scenario
- ✅ `DeleteScenarioUseCase` - Delete scenario
- ✅ `ValidateScenarioUseCase` - Validate scenario business rules

**Implementation**: Located in `Application.UseCases.Scenarios`

#### GameSession Domain Model

**Current Status**: ⚠️ Partially implemented (some operations in services)

**Use Cases**:

- ✅ `CreateGameSessionUseCase` - Create new game session
- ✅ `MakeChoiceUseCase` - Process player choice
- ✅ `ProgressSceneUseCase` - Progress to specific scene
- ⚠️ `ResumeGameSessionUseCase` - Resume paused session (currently in service)
- ⚠️ `EndGameSessionUseCase` - End session manually (currently in service)
- ⚠️ `PauseGameSessionUseCase` - Pause active session (currently in service)
- ⚠️ `GetGameSessionUseCase` - Get session by ID (currently in service)
- ⚠️ `GetGameSessionsByAccountUseCase` - List sessions for account (currently in service)
- ⚠️ `GetGameSessionsByProfileUseCase` - List sessions for profile (currently in service)
- ⚠️ `GetInProgressSessionsUseCase` - Get active sessions (currently in service)
- ⚠️ `GetSessionStatsUseCase` - Get session statistics (currently in service)
- ⚠️ `CheckAchievementsUseCase` - Check for achievements (currently in service)
- ⚠️ `SelectCharacterUseCase` - Assign character to session (currently in service)
- ⚠️ `DeleteGameSessionUseCase` - Delete session (currently in service)

**Implementation**: Partial - some use cases exist, others need to be created

**Recommendation**: Migrate all service methods to dedicated use cases

### Character Domain Models

#### CharacterMap Domain Model

**Current Status**: ❌ No use cases (all operations in services)

**Use Cases** (Should be implemented):

- ❌ `GetCharacterMapsUseCase` - Get all character maps
- ❌ `GetCharacterMapUseCase` - Get character map by ID
- ❌ `CreateCharacterMapUseCase` - Create new character map
- ❌ `UpdateCharacterMapUseCase` - Update character map
- ❌ `DeleteCharacterMapUseCase` - Delete character map
- ❌ `ImportCharacterMapUseCase` - Import from YAML
- ❌ `ExportCharacterMapUseCase` - Export to YAML

**Current Implementation**: `CharacterMapApiService` (should be refactored)

**Recommendation**: Create `Application.UseCases.CharacterMaps` directory and migrate service logic

### User Domain Models

#### Account Domain Model

**Current Status**: ❌ No use cases (all operations in services)

**Use Cases** (Should be implemented):

- ❌ `GetAccountUseCase` - Get account by ID
- ❌ `GetAccountByEmailUseCase` - Get account by email
- ❌ `CreateAccountUseCase` - Create new account
- ❌ `UpdateAccountUseCase` - Update account details
- ❌ `UpdateAccountSettingsUseCase` - Update account settings
- ❌ `UpdateSubscriptionUseCase` - Update subscription details
- ❌ `AddUserProfileToAccountUseCase` - Link profile to account
- ❌ `RemoveUserProfileFromAccountUseCase` - Unlink profile from account
- ❌ `AddCompletedScenarioUseCase` - Mark scenario as completed
- ❌ `GetCompletedScenariosUseCase` - Get completed scenarios

**Current Implementation**: `AccountApiService` (should be refactored)

**Recommendation**: Create `Application.UseCases.Accounts` directory and migrate service logic

#### UserProfile Domain Model

**Current Status**: ✅ Fully implemented with use cases

**Use Cases**:

- ✅ `CreateUserProfileUseCase` - Create new profile
- ✅ `GetUserProfileUseCase` - Get profile by ID
- ✅ `UpdateUserProfileUseCase` - Update profile
- ✅ `DeleteUserProfileUseCase` - Delete profile (COPPA compliant)

**Implementation**: Located in `Application.UseCases.UserProfiles`

#### PendingSignup Domain Model

**Current Status**: ❌ No use cases (all operations in services)

**Use Cases** (Should be implemented):

- ❌ `CreatePendingSignupUseCase` - Create signup request
- ❌ `GetPendingSignupUseCase` - Get signup by code
- ❌ `ValidatePendingSignupUseCase` - Validate signup code
- ❌ `CompletePendingSignupUseCase` - Complete signup process
- ❌ `ExpirePendingSignupUseCase` - Mark signup as expired

**Current Implementation**: `PasswordlessAuthService` (should be refactored)

**Recommendation**: Create `Application.UseCases.Authentication` directory

### Badge & Achievement Domain Domain Models

#### UserBadge Domain Model

**Current Status**: ❌ No use cases (all operations in services)

**Use Cases** (Should be implemented):

- ❌ `AwardBadgeUseCase` - Award badge to user profile
- ❌ `GetUserBadgesUseCase` - Get badges for user profile
- ❌ `GetBadgeUseCase` - Get badge by ID
- ❌ `GetBadgesByAxisUseCase` - Get badges for specific axis
- ❌ `RevokeBadgeUseCase` - Revoke badge (admin only)

**Current Implementation**: `UserBadgeApiService` (should be refactored)

**Recommendation**: Create `Application.UseCases.Badges` directory and migrate service logic

#### BadgeConfiguration Domain Model

**Current Status**: ❌ No use cases (all operations in services)

**Use Cases** (Should be implemented):

- ❌ `GetBadgeConfigurationsUseCase` - Get all badge configurations
- ❌ `GetBadgeConfigurationUseCase` - Get configuration by ID
- ❌ `GetBadgeConfigurationsByAxisUseCase` - Get configurations for axis
- ❌ `CreateBadgeConfigurationUseCase` - Create new configuration
- ❌ `UpdateBadgeConfigurationUseCase` - Update configuration
- ❌ `DeleteBadgeConfigurationUseCase` - Delete configuration
- ❌ `ImportBadgeConfigurationUseCase` - Import from YAML
- ❌ `ExportBadgeConfigurationUseCase` - Export to YAML

**Current Implementation**: `BadgeConfigurationApiService` (should be refactored)

**Recommendation**: Create `Application.UseCases.BadgeConfigurations` directory

### Media & Content Domain Models

#### MediaAsset / MediaMetadata Domain Models

**Current Status**: ❌ No use cases (all operations in services)

**Use Cases** (Should be implemented):

- ❌ `UploadMediaUseCase` - Upload media asset
- ❌ `GetMediaUseCase` - Get media by ID
- ❌ `GetMediaByFilenameUseCase` - Get media by filename
- ❌ `ListMediaUseCase` - List media with filtering
- ❌ `UpdateMediaMetadataUseCase` - Update media metadata
- ❌ `DeleteMediaUseCase` - Delete media asset
- ❌ `DownloadMediaUseCase` - Download media file

**Current Implementation**: `MediaApiService`, `MediaUploadService`, `MediaQueryService`, `MediaMetadataService` (should be refactored)

**Recommendation**: Create `Application.UseCases.Media` directory and migrate service logic

#### AvatarConfiguration Domain Model

**Current Status**: ❌ No use cases (all operations in services)

**Use Cases** (Should be implemented):

- ❌ `GetAvatarConfigurationsUseCase` - Get all avatar configurations
- ❌ `GetAvatarsByAgeGroupUseCase` - Get avatars for age group
- ❌ `CreateAvatarConfigurationUseCase` - Create new configuration
- ❌ `UpdateAvatarConfigurationUseCase` - Update configuration
- ❌ `DeleteAvatarConfigurationUseCase` - Delete configuration
- ❌ `AssignAvatarToAgeGroupUseCase` - Assign avatar to age group

**Current Implementation**: `AvatarApiService` (should be refactored)

**Recommendation**: Create `Application.UseCases.Avatars` directory

#### ContentBundle Domain Model

**Current Status**: ❌ No use cases (all operations in services)

**Use Cases** (Should be implemented):

- ❌ `GetContentBundlesUseCase` - Get all bundles
- ❌ `GetContentBundleUseCase` - Get bundle by ID
- ❌ `GetContentBundlesByAgeGroupUseCase` - Get bundles for age group
- ❌ `CreateContentBundleUseCase` - Create new bundle
- ❌ `UpdateContentBundleUseCase` - Update bundle
- ❌ `DeleteContentBundleUseCase` - Delete bundle
- ❌ `AddScenarioToBundleUseCase` - Add scenario to bundle
- ❌ `RemoveScenarioFromBundleUseCase` - Remove scenario from bundle
- ❌ `CheckBundleAccessUseCase` - Check if account has access to bundle

**Current Implementation**: `ContentBundleService` (should be refactored)

**Recommendation**: Create `Application.UseCases.ContentBundles` directory

## Use Case Implementation Guidelines

### When to Create a Use Case

Create a use case when:

1. **Business Logic**: The operation contains business rules or validation
2. **Multiple Steps**: The operation involves multiple repository calls or coordination
3. **Transaction Management**: The operation requires transaction boundaries
4. **Reusability**: The operation may be called from multiple places
5. **Testability**: The operation needs isolated unit testing

### When to Keep in Service

Keep operations in services when:

1. **Simple CRUD**: Trivial get/set operations with no business logic
2. **Orchestration Only**: Service only coordinates multiple use cases
3. **Infrastructure Concerns**: Operations deal with external systems (email, storage, etc.)

### Migration Strategy

1. **Identify Service Methods**: Review service classes for business logic
2. **Extract Use Cases**: Create use case classes in `Application.UseCases.{Domain}`
3. **Update Services**: Refactor services to call use cases instead of direct repository access
4. **Update Controllers**: Ensure controllers call services (services call use cases)
5. **Add Tests**: Create unit tests for use cases

### Example Migration Pattern

**Before** (Service with business logic):

```csharp
public class CharacterMapApiService
{
    public async Task<CharacterMap> CreateCharacterMapAsync(CreateCharacterMapRequest request)
    {
        // Business logic here
        var characterMap = new CharacterMap { ... };
        await _repository.AddAsync(characterMap);
        await _unitOfWork.SaveChangesAsync();
        return characterMap;
    }
}
```

**After** (Service delegates to use case):

```csharp
public class CharacterMapApiService
{
    private readonly CreateCharacterMapUseCase _createUseCase;
    
    public async Task<CharacterMap> CreateCharacterMapAsync(CreateCharacterMapRequest request)
    {
        return await _createUseCase.ExecuteAsync(request);
    }
}
```

**Use Case**:

```csharp
public class CreateCharacterMapUseCase
{
    private readonly ICharacterMapRepository _repository;
    private readonly IUnitOfWork _unitOfWork;
    
    public async Task<CharacterMap> ExecuteAsync(CreateCharacterMapRequest request)
    {
        // Business logic here
        var characterMap = new CharacterMap { ... };
        await _repository.AddAsync(characterMap);
        await _unitOfWork.SaveChangesAsync();
        return characterMap;
    }
}
```

## Related Documentation

- [Use Cases Documentation](../usecases/README.md)
- [Architecture Documentation](../architecture/README.md)
- [Parser Domain Object Verification](../usecases/PARSER_IMPLEMENTATION_VERIFICATION.md)
- [Refactoring Status](../../architecture/REFACTORING_STATUS.md)
